/*! cloud - v1.0.0 - 2018-02-06 */
private_cloud.controller("cloudDiskController", [ "$scope", "$rootScope", "$http", "cloud_service", "$interval", "volume_service", "$state", "$timeout", function(e, t, o, l, s, a, n, u) {
    function i(t, o, l) {
        angular.forEach(t, function(t) {
            t.id == l.attachments[0].serverId && (e.disks[o].cloud = t);
        });
    }
    e.diskStatus = {
        "in-use": "已挂载",
        available: "可用",
        creating: "正在创建",
        deleting: "删除中",
        detaching: "分离中",
        attaching: "连接中",
        error: "错误"
    }, a.getVolume(), t.volume_promise.promise.then(function(t) {
        console.log(t), e.volumesUsedPercent = t.volumes.used / t.volumes.total, e.gigabytesUsedPercent = t.gigabytes.used / t.gigabytes.total;
    }), l.getCloud(), t.cloud_promise.promise.then(function(l) {
        console.log(l), e.clouds = l.data.servers, o({
            url: "/api/list_volumes",
            headers: t.headers
        }).then(function(l) {
            console.log(l), e.disks = l.data.volumes, angular.forEach(e.disks, function(l, a) {
                "in-use" != l.status && "available" != l.status && "error" != l.status && (console.log(a), 
                e["volumesInterval" + a] = s(function() {
                    o({
                        url: " /api/list_volumes/" + l.id,
                        headers: t.headers
                    }).then(function(t) {
                        console.log(t);
                        var o = t.data.volume.status;
                        e.disks[a].status = o, 0 != t.data.volume.attachments.length && i(e.clouds, a, t.data.volume), 
                        "in-use" != o && "available" != o && "error" != o || (s.cancel(e["volumesInterval" + a]), 
                        e["volumesInterval" + a] = null);
                    }, function(e) {
                        alert(e.statusText);
                    });
                }, 1e3)), 0 != l.attachments.length && i(e.clouds, a, l);
            });
        }, function(e) {
            alert(e.statusText);
        });
    }), e.deleteDisk = function(l, s, a) {
        confirm("确定删除云硬盘" + l + "吗？") && o({
            url: "/api/list_volumes/" + s,
            method: "DELETE",
            headers: t.headers
        }).then(function(t) {
            console.log(t), alert("删除成功"), e.disks.splice(a, 1);
        }, function(e) {
            alert(e.statusText);
        });
    }, e.formSubmit = function(l) {
        switch (l) {
          case "$formLinkCloud":
            o({
                url: "/api/volume_attach/" + e.selectCloud,
                method: "POST",
                headers: t.headers,
                data: {
                    volumeAttachment: {
                        volumeId: e.diskId,
                        device: "/dev/vdb"
                    }
                }
            }).then(function(e) {
                console.log(e), $("#link_cloud").modal("hide"), u(function() {
                    n.go("storage.couldDisk", {}, {
                        reload: !0
                    });
                }, 500);
            }, function(e) {
                alert(e.statusText);
            });
            break;

          case "$formCutCloud":
            confirm("确定要断开云硬盘" + e.diskName + "吗？") && o({
                url: "/api/volume_attach/" + e.linkedCloud + "/" + e.diskId,
                method: "DELETE",
                headers: t.headers
            }).then(function(e) {
                console.log(e), $("#cut_link").modal("hide"), u(function() {
                    n.go("storage.couldDisk", {}, {
                        reload: !0
                    });
                }, 1e3);
            }, function(e) {
                alert(e.statusText);
            });
        }
    }, e.showModalLinkCloud = function(t) {
        e.selectCloud = "", e.$formLinkCloud.selectCloud.$dirty = !1, e.diskId = t;
    }, e.showModalCutCloud = function(t, o, l) {
        e.linkedCloud = "", e.linkedCloud = t, e.diskId = o, e.diskName = l;
    };
} ]);
//# sourceMappingURL=cloudDisk.min.js.map